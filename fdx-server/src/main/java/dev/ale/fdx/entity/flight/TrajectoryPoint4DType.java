//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2019.10.28 at 02:58:02 PM ICT 
//


package dev.ale.fdx.entity.flight;

import java.util.ArrayList;
import java.util.List;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;

import org.hibernate.annotations.LazyCollection;
import org.hibernate.annotations.LazyCollectionOption;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;

import dev.ale.fdx.entity.base.FlightLevelOrAltitudeType;
import dev.ale.fdx.entity.base.GeographicalPositionType;
import dev.ale.fdx.entity.base.GroundSpeedType;
import dev.ale.fdx.entity.base.IndicatedAirspeedType;
import dev.ale.fdx.entity.base.PressureType;
import dev.ale.fdx.entity.base.VerticalRangeType;


/**
 * 
 *             Identifies relevant information about a trajectory point including location, altitude, 
 *             time, etc. 
 *          
 * 
 * <p>Java class for TrajectoryPoint4DType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="TrajectoryPoint4DType">
 *   &lt;complexContent>
 *     &lt;extension base="{http://www.fixm.aero/base/4.1}GeographicalPositionType">
 *       &lt;sequence>
 *         &lt;element name="altimeterSetting" type="{http://www.fixm.aero/base/4.1}PressureType" minOccurs="0"/>
 *         &lt;element name="level" type="{http://www.fixm.aero/base/4.1}FlightLevelOrAltitudeType" minOccurs="0"/>
 *         &lt;element name="metData" type="{http://www.fixm.aero/flight/4.1}MeteorologicalDataType" minOccurs="0"/>
 *         &lt;element name="pointProperty" type="{http://www.fixm.aero/flight/4.1}TrajectoryPointPropertyType" maxOccurs="2000" minOccurs="0"/>
 *         &lt;element name="predictedAirspeed" type="{http://www.fixm.aero/base/4.1}IndicatedAirspeedType" minOccurs="0"/>
 *         &lt;element name="predictedGroundspeed" type="{http://www.fixm.aero/base/4.1}GroundSpeedType" minOccurs="0"/>
 *         &lt;element name="time" type="{http://www.fixm.aero/flight/4.1}Point4DTimeChoiceType" minOccurs="0"/>
 *         &lt;element name="verticalRange" type="{http://www.fixm.aero/base/4.1}VerticalRangeType" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "TrajectoryPoint4DType", propOrder = {
    "altimeterSetting",
    "level",
    "metData",
    "pointProperty",
    "predictedAirspeed",
    "predictedGroundspeed",
    "time",
    "verticalRange"
})
@Entity(name = "TrajectoryPoint4DType")
@Table(name = "TRAJECTORYPOINT4DTYPE")
public class TrajectoryPoint4DType
    extends GeographicalPositionType
    implements Equals, HashCode
{

    protected PressureType altimeterSetting;
    protected FlightLevelOrAltitudeType level;
    protected MeteorologicalDataType metData;
    protected List<TrajectoryPointPropertyType> pointProperty;
    protected IndicatedAirspeedType predictedAirspeed;
    protected GroundSpeedType predictedGroundspeed;
    protected Point4DTimeChoiceType time;
    protected VerticalRangeType verticalRange;

    /**
     * Gets the value of the altimeterSetting property.
     * 
     * @return
     *     possible object is
     *     {@link PressureType }
     *     
     */
    @ManyToOne(targetEntity = PressureType.class, cascade = {
        CascadeType.ALL
    })
    @JoinColumn(name = "ALTIMETERSETTING_TRAJECTORYP_0")
    public PressureType getAltimeterSetting() {
        return altimeterSetting;
    }

    /**
     * Sets the value of the altimeterSetting property.
     * 
     * @param value
     *     allowed object is
     *     {@link PressureType }
     *     
     */
    public void setAltimeterSetting(PressureType value) {
        this.altimeterSetting = value;
    }

    /**
     * Gets the value of the level property.
     * 
     * @return
     *     possible object is
     *     {@link FlightLevelOrAltitudeType }
     *     
     */
    @ManyToOne(targetEntity = FlightLevelOrAltitudeType.class, cascade = {
        CascadeType.ALL
    })
    @JoinColumn(name = "LEVEL__TRAJECTORYPOINT4DTYPE_0")
    public FlightLevelOrAltitudeType getLevel() {
        return level;
    }

    /**
     * Sets the value of the level property.
     * 
     * @param value
     *     allowed object is
     *     {@link FlightLevelOrAltitudeType }
     *     
     */
    public void setLevel(FlightLevelOrAltitudeType value) {
        this.level = value;
    }

    /**
     * Gets the value of the metData property.
     * 
     * @return
     *     possible object is
     *     {@link MeteorologicalDataType }
     *     
     */
    @ManyToOne(targetEntity = MeteorologicalDataType.class, cascade = {
        CascadeType.ALL
    })
    @JoinColumn(name = "METDATA_TRAJECTORYPOINT4DTYP_0")
    public MeteorologicalDataType getMetData() {
        return metData;
    }

    /**
     * Sets the value of the metData property.
     * 
     * @param value
     *     allowed object is
     *     {@link MeteorologicalDataType }
     *     
     */
    public void setMetData(MeteorologicalDataType value) {
        this.metData = value;
    }

    /**
     * Gets the value of the pointProperty property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the pointProperty property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPointProperty().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TrajectoryPointPropertyType }
     * 
     * 
     */
    @OneToMany(targetEntity = TrajectoryPointPropertyType.class, cascade = {
        CascadeType.ALL
    },fetch = FetchType.LAZY)
    @JoinColumn(name = "POINTPROPERTY_TRAJECTORYPOIN_0")
    @LazyCollection(LazyCollectionOption.FALSE)
    public List<TrajectoryPointPropertyType> getPointProperty() {
        if (pointProperty == null) {
            pointProperty = new ArrayList<TrajectoryPointPropertyType>();
        }
        return this.pointProperty;
    }

    /**
     * 
     * 
     */
    public void setPointProperty(List<TrajectoryPointPropertyType> pointProperty) {
        this.pointProperty = pointProperty;
    }

    /**
     * Gets the value of the predictedAirspeed property.
     * 
     * @return
     *     possible object is
     *     {@link IndicatedAirspeedType }
     *     
     */
    @ManyToOne(targetEntity = IndicatedAirspeedType.class, cascade = {
        CascadeType.ALL
    })
    @JoinColumn(name = "PREDICTEDAIRSPEED_TRAJECTORY_0")
    public IndicatedAirspeedType getPredictedAirspeed() {
        return predictedAirspeed;
    }

    /**
     * Sets the value of the predictedAirspeed property.
     * 
     * @param value
     *     allowed object is
     *     {@link IndicatedAirspeedType }
     *     
     */
    public void setPredictedAirspeed(IndicatedAirspeedType value) {
        this.predictedAirspeed = value;
    }

    /**
     * Gets the value of the predictedGroundspeed property.
     * 
     * @return
     *     possible object is
     *     {@link GroundSpeedType }
     *     
     */
    @ManyToOne(targetEntity = GroundSpeedType.class, cascade = {
        CascadeType.ALL
    })
    @JoinColumn(name = "PREDICTEDGROUNDSPEED_TRAJECT_0")
    public GroundSpeedType getPredictedGroundspeed() {
        return predictedGroundspeed;
    }

    /**
     * Sets the value of the predictedGroundspeed property.
     * 
     * @param value
     *     allowed object is
     *     {@link GroundSpeedType }
     *     
     */
    public void setPredictedGroundspeed(GroundSpeedType value) {
        this.predictedGroundspeed = value;
    }

    /**
     * Gets the value of the time property.
     * 
     * @return
     *     possible object is
     *     {@link Point4DTimeChoiceType }
     *     
     */
    @ManyToOne(targetEntity = Point4DTimeChoiceType.class, cascade = {
        CascadeType.ALL
    })
    @JoinColumn(name = "TIME__TRAJECTORYPOINT4DTYPE__0")
    public Point4DTimeChoiceType getTime() {
        return time;
    }

    /**
     * Sets the value of the time property.
     * 
     * @param value
     *     allowed object is
     *     {@link Point4DTimeChoiceType }
     *     
     */
    public void setTime(Point4DTimeChoiceType value) {
        this.time = value;
    }

    /**
     * Gets the value of the verticalRange property.
     * 
     * @return
     *     possible object is
     *     {@link VerticalRangeType }
     *     
     */
    @ManyToOne(targetEntity = VerticalRangeType.class, cascade = {
        CascadeType.ALL
    })
    @JoinColumn(name = "VERTICALRANGE_TRAJECTORYPOIN_0")
    public VerticalRangeType getVerticalRange() {
        return verticalRange;
    }

    /**
     * Sets the value of the verticalRange property.
     * 
     * @param value
     *     allowed object is
     *     {@link VerticalRangeType }
     *     
     */
    public void setVerticalRange(VerticalRangeType value) {
        this.verticalRange = value;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof TrajectoryPoint4DType)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final TrajectoryPoint4DType that = ((TrajectoryPoint4DType) object);
        {
            PressureType lhsAltimeterSetting;
            lhsAltimeterSetting = this.getAltimeterSetting();
            PressureType rhsAltimeterSetting;
            rhsAltimeterSetting = that.getAltimeterSetting();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "altimeterSetting", lhsAltimeterSetting), LocatorUtils.property(thatLocator, "altimeterSetting", rhsAltimeterSetting), lhsAltimeterSetting, rhsAltimeterSetting)) {
                return false;
            }
        }
        {
            FlightLevelOrAltitudeType lhsLevel;
            lhsLevel = this.getLevel();
            FlightLevelOrAltitudeType rhsLevel;
            rhsLevel = that.getLevel();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "level", lhsLevel), LocatorUtils.property(thatLocator, "level", rhsLevel), lhsLevel, rhsLevel)) {
                return false;
            }
        }
        {
            MeteorologicalDataType lhsMetData;
            lhsMetData = this.getMetData();
            MeteorologicalDataType rhsMetData;
            rhsMetData = that.getMetData();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "metData", lhsMetData), LocatorUtils.property(thatLocator, "metData", rhsMetData), lhsMetData, rhsMetData)) {
                return false;
            }
        }
        {
            List<TrajectoryPointPropertyType> lhsPointProperty;
            lhsPointProperty = (((this.pointProperty!= null)&&(!this.pointProperty.isEmpty()))?this.getPointProperty():null);
            List<TrajectoryPointPropertyType> rhsPointProperty;
            rhsPointProperty = (((that.pointProperty!= null)&&(!that.pointProperty.isEmpty()))?that.getPointProperty():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "pointProperty", lhsPointProperty), LocatorUtils.property(thatLocator, "pointProperty", rhsPointProperty), lhsPointProperty, rhsPointProperty)) {
                return false;
            }
        }
        {
            IndicatedAirspeedType lhsPredictedAirspeed;
            lhsPredictedAirspeed = this.getPredictedAirspeed();
            IndicatedAirspeedType rhsPredictedAirspeed;
            rhsPredictedAirspeed = that.getPredictedAirspeed();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "predictedAirspeed", lhsPredictedAirspeed), LocatorUtils.property(thatLocator, "predictedAirspeed", rhsPredictedAirspeed), lhsPredictedAirspeed, rhsPredictedAirspeed)) {
                return false;
            }
        }
        {
            GroundSpeedType lhsPredictedGroundspeed;
            lhsPredictedGroundspeed = this.getPredictedGroundspeed();
            GroundSpeedType rhsPredictedGroundspeed;
            rhsPredictedGroundspeed = that.getPredictedGroundspeed();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "predictedGroundspeed", lhsPredictedGroundspeed), LocatorUtils.property(thatLocator, "predictedGroundspeed", rhsPredictedGroundspeed), lhsPredictedGroundspeed, rhsPredictedGroundspeed)) {
                return false;
            }
        }
        {
            Point4DTimeChoiceType lhsTime;
            lhsTime = this.getTime();
            Point4DTimeChoiceType rhsTime;
            rhsTime = that.getTime();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "time", lhsTime), LocatorUtils.property(thatLocator, "time", rhsTime), lhsTime, rhsTime)) {
                return false;
            }
        }
        {
            VerticalRangeType lhsVerticalRange;
            lhsVerticalRange = this.getVerticalRange();
            VerticalRangeType rhsVerticalRange;
            rhsVerticalRange = that.getVerticalRange();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "verticalRange", lhsVerticalRange), LocatorUtils.property(thatLocator, "verticalRange", rhsVerticalRange), lhsVerticalRange, rhsVerticalRange)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            PressureType theAltimeterSetting;
            theAltimeterSetting = this.getAltimeterSetting();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "altimeterSetting", theAltimeterSetting), currentHashCode, theAltimeterSetting);
        }
        {
            FlightLevelOrAltitudeType theLevel;
            theLevel = this.getLevel();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "level", theLevel), currentHashCode, theLevel);
        }
        {
            MeteorologicalDataType theMetData;
            theMetData = this.getMetData();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "metData", theMetData), currentHashCode, theMetData);
        }
        {
            List<TrajectoryPointPropertyType> thePointProperty;
            thePointProperty = (((this.pointProperty!= null)&&(!this.pointProperty.isEmpty()))?this.getPointProperty():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "pointProperty", thePointProperty), currentHashCode, thePointProperty);
        }
        {
            IndicatedAirspeedType thePredictedAirspeed;
            thePredictedAirspeed = this.getPredictedAirspeed();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "predictedAirspeed", thePredictedAirspeed), currentHashCode, thePredictedAirspeed);
        }
        {
            GroundSpeedType thePredictedGroundspeed;
            thePredictedGroundspeed = this.getPredictedGroundspeed();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "predictedGroundspeed", thePredictedGroundspeed), currentHashCode, thePredictedGroundspeed);
        }
        {
            Point4DTimeChoiceType theTime;
            theTime = this.getTime();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "time", theTime), currentHashCode, theTime);
        }
        {
            VerticalRangeType theVerticalRange;
            theVerticalRange = this.getVerticalRange();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "verticalRange", theVerticalRange), currentHashCode, theVerticalRange);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

}
