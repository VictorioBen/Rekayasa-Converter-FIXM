//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2019.10.28 at 02:58:02 PM ICT 
//


package dev.ale.fdx.entity.base;

import java.util.ArrayList;
import java.util.List;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlType;

import dev.ale.fdx.entity.flight.AbstractConstraintType;
import dev.ale.fdx.entity.flight.AbstractRouteChangeType;
import dev.ale.fdx.entity.flight.AircraftType;
import dev.ale.fdx.entity.flight.AircraftTypeReferenceType;
import dev.ale.fdx.entity.flight.AircraftTypeType;
import dev.ale.fdx.entity.flight.ArrivalType;
import dev.ale.fdx.entity.flight.BoundaryCrossingType;
import dev.ale.fdx.entity.flight.CommunicationCapabilitiesType;
import dev.ale.fdx.entity.flight.DangerousGoodsDimensionsType;
import dev.ale.fdx.entity.flight.DangerousGoodsPackageGroupType;
import dev.ale.fdx.entity.flight.DangerousGoodsPackageType;
import dev.ale.fdx.entity.flight.DangerousGoodsType;
import dev.ale.fdx.entity.flight.DeclarationTextType;
import dev.ale.fdx.entity.flight.DepartureType;
import dev.ale.fdx.entity.flight.DestinationType;
import dev.ale.fdx.entity.flight.ElapsedTimeLocationType;
import dev.ale.fdx.entity.flight.EnRouteDelayType;
import dev.ale.fdx.entity.flight.EnRouteType;
import dev.ale.fdx.entity.flight.EstimatedElapsedTimeType;
import dev.ale.fdx.entity.flight.FlightCapabilitiesType;
import dev.ale.fdx.entity.flight.FlightEmergencyType;
import dev.ale.fdx.entity.flight.FlightIdentificationType;
import dev.ale.fdx.entity.flight.FlightRouteElementType;
import dev.ale.fdx.entity.flight.FlightRouteInformationType;
import dev.ale.fdx.entity.flight.FlightType;
import dev.ale.fdx.entity.flight.LastContactType;
import dev.ale.fdx.entity.flight.LastPositionReportType;
import dev.ale.fdx.entity.flight.MeteorologicalDataType;
import dev.ale.fdx.entity.flight.NavigationCapabilitiesType;
import dev.ale.fdx.entity.flight.PerformanceProfileType;
import dev.ale.fdx.entity.flight.Point4DTimeChoiceType;
import dev.ale.fdx.entity.flight.ProfilePointType;
import dev.ale.fdx.entity.flight.RadioCommunicationFailureType;
import dev.ale.fdx.entity.flight.RadioactiveMaterialType;
import dev.ale.fdx.entity.flight.RadionuclideType;
import dev.ale.fdx.entity.flight.RankedTrajectoryType;
import dev.ale.fdx.entity.flight.ReclearanceInFlightType;
import dev.ale.fdx.entity.flight.RouteDesignatorToNextElementType;
import dev.ale.fdx.entity.flight.RouteTrajectoryType;
import dev.ale.fdx.entity.flight.ShippingInformationType;
import dev.ale.fdx.entity.flight.SpeedScheduleType;
import dev.ale.fdx.entity.flight.SupplementaryDataSourceType;
import dev.ale.fdx.entity.flight.SupplementaryDataType;
import dev.ale.fdx.entity.flight.SurveillanceCapabilitiesType;
import dev.ale.fdx.entity.flight.SurvivalCapabilitiesType;
import dev.ale.fdx.entity.flight.TemperaturesType;
import dev.ale.fdx.entity.flight.TrajectoryPointPropertyType;
import dev.ale.fdx.entity.flight.TrajectoryPointReferenceType;
import dev.ale.fdx.entity.messaging.AbstractMessageType;
import dev.ale.fdx.entity.messaging.FilingStatusType;
import dev.ale.fdx.entity.messaging.FlightPlanNegotiationStatusType;
import dev.ale.fdx.entity.messaging.FlightPlanVersionType;
import dev.ale.fdx.entity.messaging.FlightPlanVersionTypeChoiceType;
import dev.ale.fdx.entity.messaging.PlanningStatusType;
import dev.ale.fdx.entity.messaging.SubmissionStatusType;

import org.hibernate.annotations.LazyCollection;
import org.hibernate.annotations.LazyCollectionOption;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * 
 *             A base class for all classes intended to be able to support extensions.  All such 
 *             extendable classes must themselves extend this class. 
 *          
 * 
 * <p>Java class for ExtensibleType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="ExtensibleType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="extension" type="{http://www.fixm.aero/base/4.1}ExtensionType" maxOccurs="2000" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ExtensibleType", propOrder = {
		"extension"
})
@XmlSeeAlso({
	SubmissionStatusType.class,
	FlightPlanNegotiationStatusType.class,
	AbstractMessageType.class,
	FilingStatusType.class,
	FlightPlanVersionTypeChoiceType.class,
	FlightPlanVersionType.class,
	PlanningStatusType.class,
	TrueAirspeedChoiceType.class,
	TelephoneContactType.class,
	TrueAirspeedRangeType.class,
	FlightLevelOrAltitudeChoiceType.class,
	TemporalRangeType.class,
	VerticalRangeType.class,
	OnlineContactType.class,
	AtcUnitReferenceType.class,
	ColourChoiceType.class,
	PostalAddressType.class,
	SignificantPointType.class,
	TemporalChoiceType.class,
	AerodromeReferenceType.class,
	PersonOrOrganizationType.class,
	AircraftOperatorType.class,
	RadioCommunicationFailureType.class,
	RouteDesignatorToNextElementType.class,
	ShippingInformationType.class,
	FlightType.class,
	FlightRouteElementType.class,
	DepartureType.class,
	PerformanceProfileType.class,
	Point4DTimeChoiceType.class,
	MeteorologicalDataType.class,
	FlightCapabilitiesType.class,
	CommunicationCapabilitiesType.class,
	TemperaturesType.class,
	ArrivalType.class,
	DangerousGoodsPackageType.class,
	TrajectoryPointPropertyType.class,
	SupplementaryDataSourceType.class,
	SurvivalCapabilitiesType.class,
	TrajectoryPointReferenceType.class,
	ReclearanceInFlightType.class,
	SpeedScheduleType.class,
	GeographicalPositionType.class,
	AircraftTypeType.class,
	EnRouteDelayType.class,
	SurveillanceCapabilitiesType.class,
	SupplementaryDataType.class,
	DestinationType.class,
	RankedTrajectoryType.class,
	FlightLevelOrAltitudeType.class,
	RadionuclideType.class,
	RouteTrajectoryType.class,
	RadioactiveMaterialType.class,
	DangerousGoodsType.class,
	FlightIdentificationType.class,
	DeclarationTextType.class,
	LastPositionReportType.class,
	FlightRouteInformationType.class,
	FlightEmergencyType.class,
	LastContactType.class,
	NavigationCapabilitiesType.class,
	BoundaryCrossingType.class,
	EstimatedElapsedTimeType.class,
	DangerousGoodsPackageGroupType.class,
	DangerousGoodsDimensionsType.class,
	ProfilePointType.class,
	AbstractConstraintType.class,
	ElapsedTimeLocationType.class,
	EnRouteType.class,
	ContactInformationType.class,
	AircraftType.class,
	AircraftTypeReferenceType.class,
	AbstractRouteChangeType.class
})
@Entity(name = "ExtensibleType")
@Table(name = "EXTENSIBLETYPE")
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class ExtensibleType
implements Equals, HashCode
{

	protected List<ExtensionType> extension;
	@XmlAttribute(name = "Hjid")
	protected Long hjid;

	/**
	 * Gets the value of the extension property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list,
	 * not a snapshot. Therefore any modification you make to the
	 * returned list will be present inside the JAXB object.
	 * This is why there is not a <CODE>set</CODE> method for the extension property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * <pre>
	 *    getExtension().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link ExtensionType }
	 * 
	 * 
	 */
	@OneToMany(targetEntity = ExtensionType.class
			, cascade = {CascadeType.ALL}
	, fetch = FetchType.LAZY
			)
	@JoinColumn(name = "EXTENSION_EXTENSIBLETYPE_HJID")
	@LazyCollection(LazyCollectionOption.FALSE)
	public List<ExtensionType> getExtension() {
		if (extension == null) {
			extension = new ArrayList<ExtensionType>();
		}
		return this.extension;
	}

	/**
	 * 
	 * 
	 */
	public void setExtension(List<ExtensionType> extension) {
		this.extension = extension;
	}

	/**
	 * Gets the value of the hjid property.
	 * 
	 * @return
	 *     possible object is
	 *     {@link Long }
	 *     
	 */
	@Id
	@Column(name = "HJID")
	@GeneratedValue(strategy = GenerationType.AUTO)
	public Long getHjid() {
		return hjid;
	}

	/**
	 * Sets the value of the hjid property.
	 * 
	 * @param value
	 *     allowed object is
	 *     {@link Long }
	 *     
	 */
	public void setHjid(Long value) {
		this.hjid = value;
	}

	public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
		if (!(object instanceof ExtensibleType)) {
			return false;
		}
		if (this == object) {
			return true;
		}
		final ExtensibleType that = ((ExtensibleType) object);
		{
			List<ExtensionType> lhsExtension;
			lhsExtension = (((this.extension!= null)&&(!this.extension.isEmpty()))?this.getExtension():null);
			List<ExtensionType> rhsExtension;
			rhsExtension = (((that.extension!= null)&&(!that.extension.isEmpty()))?that.getExtension():null);
			if (!strategy.equals(LocatorUtils.property(thisLocator, "extension", lhsExtension), LocatorUtils.property(thatLocator, "extension", rhsExtension), lhsExtension, rhsExtension)) {
				return false;
			}
		}
		return true;
	}

	public boolean equals(Object object) {
		final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
		return equals(null, null, object, strategy);
	}

	public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
		int currentHashCode = 1;
		{
			List<ExtensionType> theExtension;
			theExtension = (((this.extension!= null)&&(!this.extension.isEmpty()))?this.getExtension():null);
			currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "extension", theExtension), currentHashCode, theExtension);
		}
		return currentHashCode;
	}

	public int hashCode() {
		final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
		return this.hashCode(null, strategy);
	}

}
